<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_RGI_14_Modbus_1" Id="{62bda0c4-94a1-40ac-8de9-3de34510af27}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'tc_no_symbol'}
FUNCTION_BLOCK FB_RGI_14_Modbus_1
VAR_INPUT
	xExecute: BOOL;
	xAbort: BOOL;
	xPowerHmi: BOOL := TRUE;
	////上电信号，反转型
	xResetRequest: BOOL;
	///[ms],1 => no invocation time limit
	dwTimeLimit: DWORD := 1;
	///[ms],0 => no executing time limit 
	dwTimeOut: DWORD;
	///系统参数
	stPara: ST_RGI_14_Sys_Para;
	///0:mannal 1:auto
	xAutoMode: BOOL;
	///初始化过程中	
	xIniting: BOOL;
	///参数设置
	stPosPara: ST_RGI_PosPara;
	///流程运行过程中
	xDeviceRunning: BOOL;
	///手动自动操作
	stOper: ST_RGI_Opera;
END_VAR
VAR_OUTPUT
	///完成条件满足
	xDone: BOOL;
	///动作正在执行
	xBusy: BOOL;
	///指令被打断
	xAborted: BOOL;
	///错误条件满足
	xError: BOOL;
	///错误码
	eErrorID: RGI_14_ERROR;
	///eMobbusErrorID: MODBUS_ERROR;//modubs 报警信息
	xRdyCmd: BOOL;
	xRefOk: BOOL;
	eClampActCmd: RGI_14_CMD;
	///0：运动中，1：到达位置；2：夹住物体；3：物体掉落	
	iClampStatus: INT;
	///夹爪夹空
	xGripClampEmpty: BOOL;
	///掉落发生
	xDropOccur: BOOL;
	///关盖失败
	xClosecoverFailure: BOOL;
	///开盖失败
	xOpencoverFailure: BOOL;
	sHmiError: STRING;
	stRGIStates: ST_RGI_HMIStates;
	eCommErrorID: BYTE;
	eOperErrorID: DWORD;
END_VAR
VAR_IN_OUT
	st_IOData: ST_RGI_14_IOData;
END_VAR
VAR
	{attribute 'tc_no_symbol'}
	_xDone: BOOL;
	{attribute 'tc_no_symbol'}
	eCmd: RGI_14_CMD;
	{attribute 'tc_no_symbol'}
	///目标力值设置
	iTorqueSet: INT := 50;
	{attribute 'tc_no_symbol'}
	///运行速度设置
	iSpeedSet: INT := 50;
	{attribute 'tc_no_symbol'}
	///位置和速度设置值	
	iPosAngleSet: INT := 500;
	{attribute 'tc_no_symbol'}
	eState: STATE;
	{attribute 'tc_no_symbol'}
	xFirstInvocation: BOOL := TRUE;
	{attribute 'tc_no_symbol'}
	xTimeOut: BOOL;
	{attribute 'tc_no_symbol'}
	tOperationTimer: TON;
	{attribute 'tc_no_symbol'}
	_tonTimeout: TON;
	{attribute 'tc_no_symbol'}
	_tonCmdTimeout: TON;
	{attribute 'tc_no_symbol'}
	_tonPulse: TON;
	{attribute 'tc_no_symbol'}
	_tonDelay: TON;
	{attribute 'tc_no_symbol'}
	_tonConnectDelay: TON;
	{attribute 'tc_no_symbol'}
	_tonConnectTimeout: TON;
	{attribute 'tc_no_symbol'}
	/// detect rising edge of command execution 
	_diCmdState: DINT;
	{attribute 'tc_no_symbol'}
	i: INT;
	{attribute 'tc_no_symbol'}
	ii: INT;
	{attribute 'tc_no_symbol'}
	_idx: INT;
	{attribute 'tc_no_symbol'}
	_xConnectError: BOOL;
	{attribute 'tc_no_symbol'}
	_fResetCheck: F_TRIG;
	{attribute 'tc_no_symbol'}
	_iRotateAngleLTemp: INT;
	{attribute 'tc_no_symbol'}
	_iRotateAngleHTemp: INT;
	{attribute 'tc_no_symbol'}
	_iRotateAngleTotalTemp: DINT;
	{attribute 'tc_no_symbol'}
	_iRotateAngleCurrentTemp: DINT;
	{attribute 'tc_no_symbol'}
	_xRotateFinish: BOOL;
	{attribute 'tc_no_symbol'}
	_iConnectState: INT := 0;
	{attribute 'tc_no_symbol'}
	_connectTon: TON;
	{attribute 'tc_no_symbol'}
	_rManual: R_TRIG;
	{attribute 'tc_no_symbol'}
	_fManual: F_TRIG;
	{attribute 'tc_no_symbol'}
	_xModeChange: BOOL;
	{attribute 'tc_no_symbol'}
	///上电是默认读取模式的
	_xReadStatus: BOOL := TRUE;
	{attribute 'tc_no_symbol'}
	_iCount: INT := 0;
	{attribute 'tc_no_symbol'}
	_iAbortState: INT := 0;
	{attribute 'tc_no_symbol'}
	_fPowerOn :F_TRIG;
  {attribute 'tc_no_symbol'}
	_rHMIControl: R_TRIG;
	{attribute 'tc_no_symbol'}
	_iNGCount: INT;
	{attribute 'tc_no_symbol'}
	///4:控制反馈数据，5:状态反馈数据
	_aRead_VAR: ARRAY[4..5] OF FB_MBReadRegs;
	{attribute 'tc_no_symbol'}
	///0:初始化控制；1:夹紧控制；2:旋转绝对控制；3:旋转相对控制
	_aWtirt_VAR: ARRAY[0..3] OF FB_MBWriteRegs;
	{attribute 'tc_no_symbol'}
	///0:初始化控制；1:夹紧控制；2:旋转绝对控制；3:旋转相对控制；4:控制反馈数据，5:状态反馈数据	
	_aEnableSignal: ARRAY[0..5] OF BOOL;
	{attribute 'tc_no_symbol'}
	///反馈数据	
	_aFeedbackData: ARRAY[4..5, 0..11] OF INT;
	{attribute 'tc_no_symbol'}
	///控制参数	
	_aControlData: ARRAY[0..3, 0..3] OF INT;
	{attribute 'tc_no_symbol'}
	_iChannelIndex: INT;
	{attribute 'tc_no_symbol'}
	_xConnect_ERROR: BOOL;
	{attribute 'tc_no_symbol'}
	iCMDNGIndex: INT;
	{attribute 'tc_no_symbol'}
	_xBusy: BOOL;
	{attribute 'tc_no_symbol'}
	///发送状态标志位
	_iSendReceiveState: INT := 0;
	{attribute 'tc_no_symbol'}
	_tonDelay1: TON;
	{attribute 'tc_no_symbol'}
	_tonDelay2: TON;
	{attribute 'tc_no_symbol'}
	_iComNGCount: INT;
	{attribute 'tc_no_symbol'}
	///初始化指令触发
	_rHMIInit: R_TRIG;
	{attribute 'tc_no_symbol'}
	///初始化指令触发
	_rInit: R_TRIG;
	{attribute 'tc_no_symbol'}
	///夹紧轴指令触发
	_rHMIClamp: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///夹紧轴指令触发
	_rHMIRelease: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///夹紧轴指令触发
	_rClamp: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///夹紧轴指令触发
	_rRelease: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rHMIRotateClamp: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rHMIRotateClampRef: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rHMIRotateRelease: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rHMIRotateReleaseRef: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rRotateClamp: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rRotateRelease: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rRotateClampRef: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	///旋转轴指令触发	
	_rRotateReleaseRef: ARRAY[1..10] OF R_TRIG;
	{attribute 'tc_no_symbol'}
	_Angle_rec: INT;
	{attribute 'tc_no_symbol'}
	///是否有手动操作，是否有自动操作
	_xHMIOpe: BOOL;
	{attribute 'tc_no_symbol'}
	///是否有手动操作，是否有自动操作
	_xAutoOpe: BOOL;
END_VAR
VAR_TEMP
	{attribute 'tc_no_symbol'}
	xAgain: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[xAgain:=0;
ACTMap();//数据映射
ConnectAction();//触发通信连接功能连接
_fResetCheck(CLK:=xResetRequest OR stOper.xHMIReset);//reset
IF eState<>STATE.DORMANT
THEN
	_rHMIInit(CLK:=FALSE) ;
	_rInit(CLK:=FALSE) ;
	 FOR ii :=1 TO 10 DO
		 _rHMIClamp[ii](CLK:=FALSE);
		 _rHMIRelease[ii](CLK:=FALSE);
		 _rClamp[ii](CLK:=FALSE);
		 _rRelease[ii](CLK:=FALSE);
		 _rHMIRotateClamp[ii](CLK:=FALSE);
		 _rHMIRotateRelease[ii](CLK:=FALSE);
		 _rRotateClamp[ii](CLK:=FALSE);
		 _rRotateRelease[ii](CLK:=FALSE);
		 _rRotateClampRef[ii](CLK:=FALSE);
		 _rRotateReleaseRef[ii](CLK:=FALSE);
		 _rHMIRotateClampRef[ii](CLK:=FALSE);
		 _rHMIRotateReleaseRef[ii](CLK:=FALSE);		 
	 END_FOR
END_IF
REPEAT
	CASE eState OF
		STATE.DORMANT:
				HandleDormantState(xAgain=> xAgain);
		STATE.EXECUTING:
				HandleExecutingState(xAgain=> xAgain);
		STATE.DONE:
				HandleDoneState(xAgain=> xAgain);
		STATE.INERROR:
				HandleErrorState(xAgain=> xAgain);
		STATE.ABORTING:
				HandleAbortingState(xAgain=> xAgain);
		STATE.ABORTED:
				HandleAbortedState(xAgain=> xAgain);
		STATE.RESETING:
				HandleResettingState(xAgain=> xAgain);
	END_CASE
UNTIL (xAgain=0)
END_REPEAT

//报错信息提示	
CASE eErrorID OF
	RGI_14_ERROR.NO_ERROR:
		sHmiError:='NO_ERROR';	
  RGI_14_ERROR.FLT_PARA:
		sHmiError:='FLT_PARA';	
  RGI_14_ERROR.FLT_CONNECT:
		sHmiError:='FLT_CONNECT';	
  RGI_14_ERROR.FLT_RDYCMD:
		sHmiError:='FLT_RDYCMD';	
	RGI_14_ERROR.FLT_DEVICE_ERROR:
		sHmiError:='FLT_DEVICE_ERROR';	
	RGI_14_ERROR.FLT_POWERON:
		sHmiError:='FLT_POWERON';	
  RGI_14_ERROR.FLT_CLAMP_TIMEOUT:
		sHmiError:='FLT_CLAMP_TIMEOUT';	
  RGI_14_ERROR.FLT_ROTATE_TIMEOUT:
		sHmiError:='FLT_ROTATE_TIMEOUT';	
  RGI_14_ERROR.FLT_ORG_TIMEOUT:
		sHmiError:='FLT_ORG_TIMEOUT';	
	RGI_14_ERROR.FLT_CLAMPCMD_TIMEOUT:
		sHmiError:='FLT_CLAMPCMD_TIMEOUT';	
  RGI_14_ERROR.FLT_ROTATECMDABS_TIMEOUT:
		sHmiError:='FLT_ROTATECMDABS_TIMEOUT';
  RGI_14_ERROR.FLT_ROTATECMDREF_TIMEOUT:
		sHmiError:='FLT_ROTATECMDREF_TIMEOUT';			
  RGI_14_ERROR.FLT_ORGCMD_TIMEOUT:
		sHmiError:='FLT_ORGCMD_TIMEOUT';	
	RGI_14_ERROR.FLT_CLAMP_DROP:
		sHmiError:='FLT_CLAMP_DROP';	  
  RGI_14_ERROR.FLT_xRefOk:
		sHmiError:='FLT_xRefOk';	
	RGI_14_ERROR.FLT_CLAMP_PARA:
		sHmiError:='FLT_CLAMP_PARA';		
	RGI_14_ERROR.FLT_ClAMP_RELEASEFAIL:
		sHmiError:='FLT_ClAMP_RELEASEFAIL';	
  RGI_14_ERROR.FLT_ClAMP_CLAMPFAIL:
		sHmiError:='FLT_ClAMP_CLAMPFAIL';	
	RGI_14_ERROR.FLT_ROTATE_CLAMPFAIL:
		sHmiError:='FLT_ROTATE_CLAMPFAIL';	
	RGI_14_ERROR.FLT_ROTATE_RELEASEFAIL:
		sHmiError:='FLT_ROTATE_RELEASEFAIL';		
END_CASE

//检测是否有手动操作
_xHMIOpe := stOper.xHMInitButton;
FOR i := 1 TO 10 BY 1
DO
	_xHMIOpe := _xHMIOpe OR stOper.aHMIClampButton[i] OR stOper.aHMIReleaseButton[i] OR stOper.aHMIRotateClampButton[i] OR stOper.aHMIRotateClampRefButton[i] 
							OR stOper.aHMIRotateReleaseButton[i] OR stOper.aHMIRotateReleaseRefButton[i];
END_FOR

//检测是否有自动操作指令
_xAutoOpe := stOper.xInitControl;
FOR i := 1 TO 10 BY 1
DO
	_xAutoOpe := _xAutoOpe OR stOper.aClampControl[i] OR stOper.aReleaseControl[i] OR stOper.aRotateClampControl[i] OR stOper.aRotateClampRefControl[i] 
							OR stOper.aRotateReleaseControl[i] OR stOper.aRotateReleaseRefControl[i];
END_FOR]]></ST>
    </Implementation>
    <Folder Name="Control" Id="{adc39d03-2d40-42b8-a2e2-1f356d2f2705}" />
    <Method Name="AbortAction" Id="{c3151ffc-b0a8-4037-a1f6-b7e26830d93c}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PROTECTED AbortAction
VAR_OUTPUT
	xComplete: BOOL;
	eErrorID: RGI_14_ERROR;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
* Cleaning
* => abort all running operation
* => if an NBS.ERROR codition is reached, set eErrorID to a Value rather then NBS.RGI_14_ERROR.NO_ERROR 
*)
CASE _iAbortState OF 
	0://复位所以的控制信号

	ELSE
		;	
END_CASE


	

]]></ST>
      </Implementation>
    </Method>
    <Action Name="ACTCheckRotateFinish" Id="{3e77b40b-7692-49b0-b49c-a3cb2a8bedf4}" FolderPath="Control\">
      <Implementation>
        <ST><![CDATA[(******************************检测旋转是否完成*************************************)
_xRotateFinish := FALSE;
IF eCmd = RGI_14_CMD.Cmd_RotateAbsClamp OR eCmd = RGI_14_CMD.Cmd_RotateAbsRelease //绝对旋转模式
THEN
	//检测是否已经处于目标位置
	IF iPosAngleSet = st_IOData.I_RotateAngleL
	THEN
		_xRotateFinish := TRUE;
	END_IF	
END_IF
IF eCmd = RGI_14_CMD.Cmd_RoratRelClamp OR eCmd = RGI_14_CMD.Cmd_RoratRelRelease//增量旋转模式
THEN	
	//使用计算公式来进行预测是否已经到目标位置
	_iRotateAngleTotalTemp := _iRotateAngleHTemp * 32768 + _iRotateAngleLTemp + iPosAngleSet;
	_iRotateAngleCurrentTemp := st_IOData.I_RotateAngleH * 32768 + st_IOData.I_RotateAngleL;
	IF _iRotateAngleTotalTemp = _iRotateAngleCurrentTemp
	THEN
		_xRotateFinish := TRUE;
	END_IF
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACTMap" Id="{0f39d4b0-e1fe-4637-bb27-ddbc6355a2ee}" FolderPath="Control\">
      <Implementation>
        <ST><![CDATA[//进行数据映射的前提条件是外部所配置的参数是没有问题的
IF stPara.strSlaveIP <> '' 
THEN
	//夹爪设置反馈
	st_IOData.i_Init			:=_aFeedbackData[4,0];
	st_IOData.i_ClampForceSet	:=_aFeedbackData[4,1];
	
	st_IOData.i_ClampPosSet		:=_aFeedbackData[4,3];	
	st_IOData.i_ClampSpeedSet	:=_aFeedbackData[4,4];
	st_IOData.i_RotateAngleLSet	:=_aFeedbackData[4,5];
	st_IOData.i_RotateAngleHSet	:=_aFeedbackData[4,6];
	st_IOData.i_RotateSpeedSet	:=_aFeedbackData[4,7];
	st_IOData.i_RotateForseSet	:=_aFeedbackData[4,8];
	st_IOData.i_RotateRelAngle	:=_aFeedbackData[4,9];
	
	//夹爪状态反馈
	st_IOData.I_ClampInit := _aFeedbackData[5,0];
	st_IOData.I_ClampState := _aFeedbackData[5,1];
	st_IOData.I_CurrentPos := _aFeedbackData[5,2];
	st_IOData.I_DeviceERRORState := _aFeedbackData[5,5];
	st_IOData.I_RotateAngleL := _aFeedbackData[5,8];
	st_IOData.I_RotateAngleH := _aFeedbackData[5,9];
	st_IOData.I_RotateInit := _aFeedbackData[5,10];
	st_IOData.I_RotateState := _aFeedbackData[5,11];			
	//夹爪状态
	iClampStatus := st_IOData.I_ClampState ;
	
	//进行输出数据刷新(外面一定要用保持性的数据来定义)
	_aControlData[0,0] := st_IOData.O_Init;//同时初始化夹紧轴和旋转轴
	_aControlData[1,0] := st_IOData.O_ClampForceSet;//夹紧力值设计
	_aControlData[1,2] := st_IOData.O_ClampPosSet;//夹紧位置设置
	_aControlData[1,3] := st_IOData.O_ClampSpeedSet;//夹紧速度设置
	//旋转绝对定位
	IF eCmd = RGI_14_CMD.Cmd_RotateAbsClamp OR eCmd = RGI_14_CMD.Cmd_RotateAbsRelease
	THEN
		_aControlData[2,0]	:= st_IOData.O_RotateAngleLSet;//绝对旋转角度设置1
		_aControlData[2,1] := st_IOData.O_RotateAngleHSet;//绝对旋转角度设置2	
		_aControlData[2,2] := st_IOData.O_RotateSpeedSet;//旋转速度设计
		_aControlData[2,3] := st_IOData.O_RotateForseSet;//旋转力值设计		
	END_IF
	//旋转相对定位
	IF eCmd = RGI_14_CMD.Cmd_RoratRelClamp OR eCmd = RGI_14_CMD.Cmd_RoratRelRelease
	THEN
		_aControlData[3,0] := st_IOData.O_RotateSpeedSet;//旋转速度设计
		_aControlData[3,1] := st_IOData.O_RotateForseSet;//旋转力值设计
		_aControlData[3,2] := st_IOData.O_RotateRelAngle;//旋转相对角度设计
	END_IF
	
END_IF

(****************************夹紧轴状态读取(此时一定是模块连接上的，此时刷新周期不要太短，兼容效率***************************)
_tonPulse(IN:=NOT _tonPulse.Q , PT:=T#200MS);//产生100ms的脉冲信号
IF _xReadStatus  //一定要处于通信正常状态
THEN
	_aRead_VAR[5].bExecute := _tonPulse.Q;//保证通信不断
END_IF

xRdyCmd := xPowerHmi AND(( eState = STATE.DORMANT ) OR (NOT xAutoMode AND _xAutoOpe AND eState = STATE.DONE ));//rdy显示变化;
_rInit(CLK:= xIniting);//检测是否是初始化中，如果是的去切换模式
IF _rInit.Q
THEN
 eState := STATE.RESETING;
END_IF 
//检测是否有模式变化
_fManual(CLK:=xAutoMode);
_rManual(CLK:=xAutoMode);
IF eState <> STATE.DORMANT//只有在运行的时候，才会检测是否有模式切换发生
THEN
	IF _fManual.Q OR _rManual.Q
	THEN
		_xModeChange := TRUE;
	END_IF
END_IF

(****************************电源控制********************************************)

_fPowerOn(CLK:= xPowerHmi);//驱动器断电的时候需要将初始化完成信号给清除掉
IF _fPowerOn.Q
THEN
	xRefOk := FALSE;//断电再上电之后需要重新初始化
END_IF

(*****************************夹爪状态显示*****************************)
xDone := _xDone AND xExecute;//判断是否处于当前流程的Done状态
xDropOccur :=( eClampActCmd = RGI_14_CMD.Cmd_Clamp ) AND ( st_IOData.I_ClampState = 3 );
xGripClampEmpty := xError AND eErrorID = RGI_14_ERROR.FLT_ClAMP_CLAMPFAIL AND xExecute;//关盖失败判定
xClosecoverFailure := xError AND eErrorID = RGI_14_ERROR.FLT_ROTATE_CLAMPFAIL AND xExecute;//关盖失败判定
xOpencoverFailure := xError AND eErrorID = RGI_14_ERROR.FLT_ROTATE_RELEASEFAIL AND xExecute;//开盖失败评定

(*****************************触摸屏状态显示*****************************)
stRGIStates.xDone:=xDone;
stRGIStates.xBusy:=xBusy;
stRGIStates.xRefOk:=xRefOk;
stRGIStates.xRdyCmd:=xRdyCmd;
stRGIStates.eErrorID:=eErrorID;
stRGIStates.sHmiError:=sHmiError;
stRGIStates.iClampStatus:=iClampStatus;
stRGIStates.xClosecoverFailure:=xClosecoverFailure;
stRGIStates.xGripClampEmpty:=xGripClampEmpty;
stRGIStates.xOpencoverFailure:=xOpencoverFailure;
stRGIStates.xGripClampEmpty:=xGripClampEmpty;
stRGIStates.xError:=xError;



]]></ST>
      </Implementation>
    </Action>
    <Method Name="CmdClampAction" Id="{8395281e-8269-4e22-a90a-7fa96a4b8e12}" FolderPath="Control\">
      <Declaration><![CDATA[METHOD PROTECTED CmdClampAction
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// return the real actual fault number
IF eErrorID <> RGI_14_ERROR.NO_ERROR
THEN
  RETURN;  
END_IF
  
IF NOT xRefOk THEN
	eErrorID := RGI_14_ERROR.FLT_xRefOk;
	RETURN;
END_IF

IF iPosAngleSet < 0 OR iPosAngleSet > 1000//夹紧参数错误
THEN
	eErrorID := RGI_14_ERROR.FLT_CLAMP_PARA;
	RETURN;
END_IF

CASE _diCmdState OF
	0://判断对应指令，是否已经处于完成状态，防止出现重复触发情况
		_tonDelay(IN:= FALSE);
		IF NOT _aRead_VAR[5].bExecute THEN		
			_diCmdState := _diCmdState + 1;
		END_IF	
		
	1://传送力值和速度参数
		_tonDelay(IN:= TRUE,pt:=T#20MS);
		st_IOData.O_ClampForceSet	:= iTorqueSet;
		st_IOData.O_ClampSpeedSet	:= iSpeedSet;	
		st_IOData.O_ClampPosSet 	:= iPosAngleSet;	
		IF _tonDelay.Q 
		THEN
			//复位定时器
				_tonDelay(IN:=FALSE);
				_tonCmdTimeout(in:=FALSE);
				_tonTimeout(in:=FALSE);	
			 _aEnableSignal[1]:=TRUE;	
			 _diCmdState := _diCmdState+1;
	 END_IF				
		
	2://等待反应，设置读取参数
		_tonDelay(IN:= NOT _aEnableSignal[1],PT:=T#300MS);//此时电动夹爪一定已经响应
		IF _tonDelay.Q//
		THEN		
			_diCmdState := _diCmdState +1;			
		END_IF	
		
		IF _iSendReceiveState = 999
		THEN
			iCMDNGIndex := 1;
			eErrorID := RGI_14_ERROR.FLT_CLAMPCMD_TIMEOUT;		
			_diCmdState := 999;
		END_IF	
		
	3://读取数据
		_tonCmdTimeout(in:=FALSE);
		_tonDelay(IN:=FALSE);	
		_tonTimeout(in:=TRUE,pt:=T#10S);//设置超时时间 
		_aEnableSignal[5] := TRUE;//触发读取反馈数据	
		_diCmdState := _diCmdState +1; 
	
	4://等待运行完成
		_tonTimeout(in:=TRUE,pt:=T#10S); 
		_tonCmdTimeout(IN:= TRUE,pt:=T#2S);				
		IF NOT _aEnableSignal[5] //等待读取数据完成
		THEN	
			_tonDelay(IN:= TRUE,pt:=T#40MS);//设置刷新周期
			IF _tonDelay.Q
			THEN
				_diCmdState := 3;//回到上一步重新进行状态刷新
			END_IF
			
			IF (st_IOData.I_ClampState = 1 OR stOper.xTestMode )AND st_IOData.O_ClampPosSet = st_IOData.I_CurrentPos AND //松开位置成功
			   eCmd = RGI_14_CMD.Cmd_Release	//松开指令
			THEN			
				_tonCmdTimeout(in:=FALSE);
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF		
			IF (st_IOData.I_ClampState = 2 OR stOper.xTestMode) AND//夹住物体
				 eCmd = RGI_14_CMD.Cmd_Clamp	//夹紧指令
			THEN			
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF			
		//非测试模式才启动检测
		IF NOT stOper.xTestMode THEN	
			IF st_IOData.I_ClampState = 2 AND //松开位置的时候，没有松开到位置，松开失败
				 eCmd = RGI_14_CMD.Cmd_Release	//松开指令
			THEN	
				_iNGCount := _iNGCount + 1;		
				IF _iNGCount <= 3
				THEN
					_tonDelay(IN:=FALSE);
					_diCmdState := _diCmdState + 1;
				ELSE
					_tonTimeout(in:=FALSE);  
					eErrorID := RGI_14_ERROR.FLT_ClAMP_RELEASEFAIL;		
					_diCmdState := 999;
				END_IF				
			END_IF		
			IF st_IOData.I_ClampState = 1 AND st_IOData.O_ClampPosSet = st_IOData.I_CurrentPos AND//没有夹住物体，到位置，判定夹持失败
				 eCmd = RGI_14_CMD.Cmd_Clamp	//夹紧指令
			THEN
				_iNGCount := _iNGCount + 1;		
				IF _iNGCount <= 3
				THEN
					_tonDelay(IN:=FALSE);
					_diCmdState := _diCmdState + 1;
				ELSE
					_tonCmdTimeout(in:=FALSE);
					_tonTimeout(in:=FALSE);  			
					eErrorID := RGI_14_ERROR.FLT_ClAMP_CLAMPFAIL;		
					_diCmdState := 999;
				END_IF
			END_IF		
		END_IF
	END_IF
	
	IF _iSendReceiveState = 999//旋转指令响应超时
	THEN
		iCMDNGIndex := 3;
		eErrorID := RGI_14_ERROR.FLT_CLAMPCMD_TIMEOUT;		
		_diCmdState := 999;
	END_IF		
	
	IF _tonTimeout.Q//旋转动作超时
	THEN
		_iNGCount := _iNGCount + 1;
		IF _iNGCount >= 2
		THEN
			eErrorID := RGI_14_ERROR.FLT_CLAMP_TIMEOUT;
			_diCmdState := 999;
		ELSE
			_aEnableSignal[5] := FALSE;
			_diCmdState := 0;
		END_IF
	END_IF
	
	5://报警再次确定
		_tonDelay(IN:= TRUE,pt:=T#50MS);
		IF _tonDelay.Q//做延时刷新
		THEN			
			_diCmdState :=3;
		END_IF
			
ELSE
	;	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdRotateAction_ABS" Id="{914f69a7-5d3b-46e9-bfd5-41021dd7ab72}" FolderPath="Control\">
      <Declaration><![CDATA[METHOD PROTECTED CmdRotateAction_ABS
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// return the real actual fault number
IF eErrorID <> RGI_14_ERROR.NO_ERROR
THEN
  RETURN;  
END_IF
  
IF NOT xRefOk THEN//设备没有原点报警
	eErrorID := RGI_14_ERROR.FLT_xRefOk;
	RETURN;
END_IF

CASE _diCmdState OF
	0://判断是否已经处于目标位置或者夹取完成状态，防止出现重复触发情况
		_tonDelay(IN:= FALSE);
		IF NOT _aRead_VAR[5].bExecute THEN		
			_diCmdState := _diCmdState + 1;
		END_IF		
		
	1://传送参数	
		_tonDelay(IN:= TRUE,PT:=T#20MS);//等待设备运行起来
		_iRotateAngleLTemp := st_IOData.I_RotateAngleL;
		_iRotateAngleHTemp := st_IOData.I_RotateAngleH;		
		st_IOData.O_RotateForseSet := iTorqueSet;
		st_IOData.O_RotateSpeedSet := iSpeedSet;
		st_IOData.O_RotateAngleLSet := iPosAngleSet;
		st_IOData.O_RotateRelAngle := 0;
		IF _tonDelay.Q 
		THEN
			//复位定时器
				_tonDelay(IN:=FALSE);
				_tonCmdTimeout(in:=FALSE);
				_tonTimeout(in:=FALSE);	
			 _aEnableSignal[2]:= TRUE;
			 _diCmdState := _diCmdState+1;
	 END_IF
	
		
	2://等待反应，设置读取参数
		_tonDelay(IN:= NOT _aEnableSignal[2],PT:=T#300MS);//此时电动夹爪一定已经响应
		IF _tonDelay.Q//
		THEN		
			_diCmdState := _diCmdState +1;			
		END_IF	
		
		IF _iSendReceiveState = 999
		THEN
			iCMDNGIndex := 1;
			eErrorID := RGI_14_ERROR.FLT_CLAMPCMD_TIMEOUT;		
			_diCmdState := 999;
		END_IF								
		
	3://读取数据
		_tonCmdTimeout(in:=FALSE);
		_tonDelay(IN:=FALSE);	
		_tonTimeout(in:=TRUE,pt:=T#10S);//设置超时时间 
		_aEnableSignal[5] := TRUE;//触发读取反馈数据	
		_diCmdState := _diCmdState +1; 		
				
	4://判定旋转结果
		_tonTimeout(in:=TRUE,pt:=T#10S); 
		_tonCmdTimeout(IN:= TRUE,pt:=T#2S);				
		IF NOT _aEnableSignal[5] //等待读取数据完成
		THEN	
			_tonDelay(IN:= TRUE,pt:=T#40MS);//设置刷新周期
			IF _tonDelay.Q
			THEN
				_diCmdState := 3;//回到上一步重新进行状态刷新
			END_IF
			
			IF ( ( st_IOData.I_RotateState = 1 AND _xRotateFinish ) OR st_IOData.I_RotateState = 3 OR stOper.xTestMode ) AND _xRotateFinish AND //旋转是否到位置,只有在松开瓶盖的时候会有这种操作
				 ( eCmd = RGI_14_CMD.Cmd_RotateAbsRelease)
			THEN			
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF		
			IF ( st_IOData.I_RotateState = 2 OR st_IOData.I_RotateState = 3 OR stOper.xTestMode ) AND //旋转夹瓶盖处理，只有出现堵转（达到设置力反馈）
				 ( eCmd = RGI_14_CMD.Cmd_RotateAbsClamp)
			THEN			
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF				
		//非测试模式才启动检测
			IF NOT stOper.xTestMode THEN
				IF ( st_IOData.I_RotateState = 1 AND _xRotateFinish ) AND //关盖打滑,直接到设置位置了
					 ( eCmd = RGI_14_CMD.Cmd_RotateAbsClamp )
				THEN
					_iNGCount := _iNGCount + 1;		
					IF _iNGCount <= 3//检测是否有正时报警发生
					THEN
						_tonDelay(IN:=FALSE);
						_diCmdState := _diCmdState + 1;
					ELSE
						eErrorID := RGI_14_ERROR.FLT_ROTATE_CLAMPFAIL;
						_diCmdState := 999;
					END_IF
				END_IF
				IF ( st_IOData.I_RotateState = 2 ) AND //开盖失败，直接堵转，开不开瓶盖
					 ( eCmd = RGI_14_CMD.Cmd_RotateAbsRelease)
				THEN	
					_tonDelay(IN:= st_IOData.I_RotateState = 2,pt:=T#500MS);//判断释放堵转
					IF _tonDelay.Q THEN
						_iNGCount := _iNGCount + 1;		
						IF _iNGCount <= 3//检测是否有正时报警发生
						THEN
							_tonDelay(IN:=FALSE);
							_diCmdState := _diCmdState + 1;
						ELSE
							eErrorID := RGI_14_ERROR.FLT_ROTATE_RELEASEFAIL;
							_tonDelay(IN:= FALSE,pt:=T#10MS);
							_diCmdState := 999;
						END_IF
					END_IF
				END_IF
			END_IF
		END_IF	
		IF _iSendReceiveState = 999//旋转指令响应超时
		THEN
			iCMDNGIndex := 3;
			eErrorID := RGI_14_ERROR.FLT_ROTATECMDABS_TIMEOUT;		
			_diCmdState := 999;
		END_IF		
		IF _tonTimeout.Q//回原点动作超时
		THEN
			eErrorID := RGI_14_ERROR.FLT_ROTATE_TIMEOUT;
			_diCmdState := 999;
		END_IF
		
	5://报警再次确定
		_tonDelay(IN:= TRUE,pt:=T#50MS);
		IF _tonDelay.Q//做延时刷新
		THEN			
			_diCmdState :=3;
		END_IF	

	
ELSE
	;	
END_CASE
ACTCheckRotateFinish();//调用计算是否到位置]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdRotateAction_Ref" Id="{1ce76aa3-6a84-4429-a496-210efa035aeb}" FolderPath="Control\">
      <Declaration><![CDATA[METHOD PROTECTED CmdRotateAction_Ref
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// return the real actual fault number
IF eErrorID <> RGI_14_ERROR.NO_ERROR
THEN
  RETURN;  
END_IF
  
IF NOT xRefOk THEN//设备没有原点报警
	eErrorID := RGI_14_ERROR.FLT_xRefOk;
	RETURN;
END_IF

CASE _diCmdState OF
	0://判断是否已经处于目标位置或者夹取完成状态，防止出现重复触发情况
		_tonDelay(IN:= FALSE);
		IF NOT _aRead_VAR[5].bExecute THEN		
			_diCmdState := _diCmdState + 1;
		END_IF	
		
	1://传送参数
	  	_tonDelay(IN:= TRUE,pt:=T#20MS);//保证执行的都是当次任务 			
			_iRotateAngleLTemp := st_IOData.I_RotateAngleL;
			_iRotateAngleHTemp := st_IOData.I_RotateAngleH;		
			st_IOData.O_RotateForseSet := iTorqueSet;
			st_IOData.O_RotateSpeedSet := iSpeedSet;
			st_IOData.O_RotateRelAngle := iPosAngleSet;				
			_Angle_rec:=st_IOData.I_RotateAngleL;//将当前夹爪旋转角度储存到缓存，用来判断机构是否动作
			IF _tonDelay.Q 
			THEN
			//复位定时器
				_tonDelay(IN:=FALSE);
				_tonCmdTimeout(in:=FALSE);
				_tonTimeout(in:=FALSE);	
			 _aEnableSignal[3]:= TRUE;
			 _diCmdState := _diCmdState+1;
			END_IF		


	2://等待反应，设置读取参数
		_tonDelay(IN:= NOT _aEnableSignal[3],PT:=T#300MS);//此时电动夹爪一定已经响应
		IF _tonDelay.Q//
		THEN		
			_diCmdState := _diCmdState +1;			
		END_IF	
		
		IF _iSendReceiveState = 999
		THEN
			iCMDNGIndex := 1;
			eErrorID := RGI_14_ERROR.FLT_ROTATECMDREF_TIMEOUT;		
			_diCmdState := 999;
		END_IF								
		
	3://读取数据
		_tonCmdTimeout(in:=FALSE);
		_tonDelay(IN:=FALSE);	
		_tonTimeout(in:=TRUE,pt:=T#10S);//设置超时时间 
		_aEnableSignal[5] := TRUE;//触发读取反馈数据	
		_diCmdState := _diCmdState +1; 
					
	4://判定旋转结果
		_tonTimeout(in:=TRUE,pt:=T#10S); 
		_tonCmdTimeout(IN:= TRUE,pt:=T#2S);				
		IF NOT _aEnableSignal[5] //等待读取数据完成
		THEN	
			_tonDelay(IN:= TRUE,pt:=T#40MS);//设置刷新周期
			IF _tonDelay.Q
			THEN
				_diCmdState := 3;//回到上一步重新进行状态刷新
			END_IF
			
			IF (  st_IOData.I_RotateState = 1 OR st_IOData.I_RotateState = 3 OR stOper.xTestMode ) AND //旋转是否到位置,只有在松开瓶盖的时候会有这种操作
				 ( eCmd = RGI_14_CMD.Cmd_RoratRelRelease )
			THEN			
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF		
			IF ( st_IOData.I_RotateState = 2 OR st_IOData.I_RotateState = 3 OR stOper.xTestMode ) AND //旋转夹瓶盖处理，只有出现堵转（达到设置力反馈）
				 ( eCmd = RGI_14_CMD.Cmd_RoratRelClamp )
			THEN			
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xComplete := TRUE;
			END_IF				
			//非测试模式才启动检测
			IF NOT stOper.xTestMode THEN
				//关盖异常判断，关盖时直接旋转到位，没有遇到阻力判定为关盖失败
				IF ( st_IOData.I_RotateState = 1 ) AND //关盖打滑,直接到设置位置了,AND _Angle_rec+iPosAngleSet=st_IOData.I_RotateAngleL
					 ( eCmd = RGI_14_CMD.Cmd_RoratRelClamp )
				THEN
					_iNGCount := _iNGCount + 1;		
					IF _iNGCount <= 2//检测是否有正时报警发生
					THEN
						_tonDelay(IN:=FALSE);
						_diCmdState := 3;
					ELSE
						eErrorID := RGI_14_ERROR.FLT_ROTATE_CLAMPFAIL;
						_diCmdState := 999;
					END_IF
				END_IF
				//开盖异常判断
				IF ( st_IOData.I_RotateState = 2 ) AND //开盖失败，直接堵转，开不开瓶盖
					 ( eCmd = RGI_14_CMD.Cmd_RoratRelRelease )
				THEN	
					_tonDelay(IN:= st_IOData.I_RotateState = 2,pt:=T#500MS);//判断释放堵转
					IF _tonDelay.Q THEN
						_iNGCount := _iNGCount + 1;		
						IF _iNGCount <= 2//检测是否有正时报警发生
						THEN
							_tonDelay(IN:=FALSE);
							_diCmdState := 3;
						ELSE
							eErrorID := RGI_14_ERROR.FLT_ROTATE_RELEASEFAIL;
							_tonDelay(IN:= FALSE,pt:=T#10MS);
							_diCmdState := 999;
						END_IF
					END_IF
				END_IF
			END_IF
		END_IF	
		IF _iSendReceiveState = 999//旋转指令响应超时
		THEN
			iCMDNGIndex := 3;
			eErrorID := RGI_14_ERROR.FLT_ROTATECMDABS_TIMEOUT;		
			_diCmdState := 999;
		END_IF
		//超时判定
		IF _tonTimeout.Q//动作超时
		THEN
			eErrorID := RGI_14_ERROR.FLT_ROTATE_TIMEOUT;
			_diCmdState := 999;
		END_IF
		
	5://报警再次确定
		_tonDelay(IN:= TRUE,pt:=T#50MS);
		IF _tonDelay.Q//做延时刷新
		THEN			
			_diCmdState :=3;
		END_IF		
		
	ELSE
		;	
END_CASE
ACTCheckRotateFinish();//调用计算是否到位置]]></ST>
      </Implementation>
    </Method>
    <Action Name="ConnectAction" Id="{a99a025a-6d4c-4daf-a173-faa9868f20ac}" FolderPath="Control\">
      <Implementation>
        <ST><![CDATA[	
(**********************************调用收发功能块**********************************)
//状态反馈功能调用
_aRead_VAR[4](
	sIPAddr:= stPara.strSlaveIP, 
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 10, 
	nMBAddr:=16#100 , 
	cbLength:= 20, 
	pDestAddr:=ADR(_aFeedbackData[4,0]));	
	
_aRead_VAR[5](
	sIPAddr:= stPara.strSlaveIP, 
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 12, 
	nMBAddr:=16#200 , 
	cbLength:= 24, 
	pDestAddr:=ADR(_aFeedbackData[5,0]));		
	
//指令控制部分
_aWtirt_VAR[0](
	sIPAddr:= stPara.strSlaveIP,
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 1, 
	nMBAddr:= 16#100, 
	cbLength:= 2, 
	pSrcAddr:= ADR(_aControlData[0,0]), 
	bExecute:= , 
	tTimeout:= T#1S, 
	bBusy=> , 
	bError=> , 
	nErrId=> );	
	
_aWtirt_VAR[1](
	sIPAddr:= stPara.strSlaveIP,
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 4, 
	nMBAddr:= 16#101, 
	cbLength:= 8, 
	pSrcAddr:= ADR(_aControlData[1,0]), 
	bExecute:= , 
	tTimeout:= T#1S, 
	bBusy=> , 
	bError=> , 
	nErrId=> );	
	
_aWtirt_VAR[2](
	sIPAddr:= stPara.strSlaveIP,
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 4, 
	nMBAddr:= 16#105, 
	cbLength:= 8, 
	pSrcAddr:= ADR(_aControlData[2,0]), 
	bExecute:= , 
	tTimeout:= T#1S, 
	bBusy=> , 
	bError=> , 
	nErrId=> );	
	
_aWtirt_VAR[3](
	sIPAddr:= stPara.strSlaveIP,
	nTCPPort:= stPara.iSlavePort, 
	nUnitID:= stPara.bySlaveID, 
	nQuantity:= 3, 
	nMBAddr:= 16#107, 
	cbLength:= 6, 
	pSrcAddr:= ADR(_aControlData[3,0]), 
	bExecute:= , 
	tTimeout:= T#1S, 
	bBusy=> , 
	bError=> , 
	nErrId=> );	
	

CASE _iSendReceiveState OF 
	0:
		_tonDelay2(IN:= FALSE);
		_iChannelIndex:= -1;
		FOR i := 0 TO 5 BY 1//进行读取指令的轮训
		DO
		 IF _aEnableSignal[i]//检测有控制指令发生
		 THEN
			 _iChannelIndex:=i;    
			END_IF 
		END_FOR
		IF _iChannelIndex>=4//有读取反馈指令
		THEN								
			IF NOT _aRead_VAR[_iChannelIndex].bBusy
			THEN
				_aRead_VAR[_iChannelIndex].bExecute := _aEnableSignal[_iChannelIndex];
				_iSendReceiveState := 10;	
			END_IF													
		END_IF			
		IF _iChannelIndex>=0 AND _iChannelIndex<=3//有控制触发指令
		THEN		
			IF  NOT _aWtirt_VAR[_iChannelIndex].bBusy 
			THEN
				_aWtirt_VAR[_iChannelIndex].bExecute := _aEnableSignal[_iChannelIndex];
				_iSendReceiveState := 10;
			END_IF
		END_IF
	10://等待读取响应			
		_tonDelay2(IN:= TRUE,PT:=T#3S);
		IF _tonDelay2.Q//超时
		THEN
			_iSendReceiveState:= 999;					
		END_IF				
		IF _iChannelIndex>=4
		THEN					
			IF _aRead_VAR[_iChannelIndex].bBusy
			THEN
				_iComNGCount := 0;
				_aEnableSignal[_iChannelIndex] := FALSE;
				_aRead_VAR[_iChannelIndex].bExecute := FALSE;
				_iSendReceiveState := 0;//等待下次触发
			ELSIF _aRead_VAR[_iChannelIndex].bError
			THEN
				_iComNGCount := _iComNGCount + 1;//错误次数加一
				IF _iComNGCount >= 3//重发多次失败
				THEN
					eOperErrorID := _aRead_VAR[_iChannelIndex].nErrId;
					_aRead_VAR[_iChannelIndex].bExecute := FALSE;
					_iSendReceiveState := 999;//进入错误发生状态
				ELSE
					_tonDelay1(in:=FALSE);
					_aRead_VAR[_iChannelIndex].bExecute:= FALSE;
					_iSendReceiveState := _iSendReceiveState + 1;
				END_IF						
			END_IF			
		END_IF				
		IF _iChannelIndex>=0 AND _iChannelIndex<=3		
		THEN	
			IF _aWtirt_VAR[_iChannelIndex].bBusy
			THEN
				_iComNGCount := 0;
				_aEnableSignal[_iChannelIndex] := FALSE;
				_aWtirt_VAR[_iChannelIndex].bExecute := FALSE;
				_iSendReceiveState := 0;//等待下次触发
			ELSIF _aWtirt_VAR[_iChannelIndex].bError
			THEN
				_iComNGCount := _iComNGCount + 1;//错误次数加一
				IF _iComNGCount >= 3//重发多次失败
				THEN
					eOperErrorID := _aWtirt_VAR[_iChannelIndex].nErrId;
					_aWtirt_VAR[_iChannelIndex].bExecute := FALSE;
					_iSendReceiveState := 999;//进入错误发生状态
				ELSE
					_tonDelay1(in:=FALSE);
					_aWtirt_VAR[_iChannelIndex].bExecute:= FALSE;
					_iSendReceiveState := _iSendReceiveState + 1;
				END_IF					
			END_IF				
		END_IF
	11://延时，进行补发操作
		_tonDelay1(in:=TRUE,pt:=T#300MS);				
		IF _tonDelay1.Q
		THEN
			_iSendReceiveState := 0;
		END_IF	
	999://错误状态，等待复位发生
		_xConnect_ERROR := TRUE;
		IF _fResetCheck.Q
		THEN	
			_aWtirt_VAR[0](bExecute := FALSE);
			_aWtirt_VAR[1](bExecute := FALSE);
			_aWtirt_VAR[2](bExecute := FALSE);
			_aWtirt_VAR[3](bExecute := FALSE);			
			_aRead_VAR[4](bExecute := FALSE);
			_aRead_VAR[5](bExecute := FALSE);
			_xConnect_ERROR := FALSE;
			_iComNGCount := 0;			
			_iSendReceiveState := 0;//重新开始
		END_IF
	ELSE
		;
END_CASE		
]]></ST>
      </Implementation>
    </Action>
    <Method Name="CyclicAction" Id="{a1736788-0feb-4e5d-872e-b6e2e998b9f5}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PROTECTED CyclicAction
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF xAbort=0 THEN
    IF xFirstInvocation THEN
    (*
    * Staring
    * for then first (!) invocaion,
    * sample then input variables
    *)
			_xReadStatus := FALSE;
			_iCount := 0;
			_diCmdState := 0;
			_iAbortState := 0;
			_iNGCount := 0;
			_aRead_VAR[4].bExecute := FALSE;			
			_aRead_VAR[5].bExecute := FALSE;
			_aWtirt_VAR[0].bExecute:= FALSE;
			_aWtirt_VAR[1].bExecute:= FALSE;
			_aWtirt_VAR[2].bExecute:= FALSE;
			_aWtirt_VAR[3].bExecute:= FALSE;
			xFirstInvocation:=0;			
    END_IF    
    REPEAT 				
		  (**************************检查是否有硬件报错(检测总线是否报错)**********************************) 			
			IF stPara.strSlaveIP = '' 
			THEN
				eErrorID := RGI_14_ERROR.FLT_PARA;//参数配置错误
			END_IF
			//下面几个报警需要断驱动器的电才能消除报警
			IF st_IOData.I_DeviceERRORState <> 0 
			THEN
				eErrorID := RGI_14_ERROR.FLT_DEVICE_ERROR;//过热报警
			END_IF
		
			IF _xConnectError//检测子站是否有连接异常
			THEN
				eErrorID := RGI_14_ERROR.FLT_CONNECT;//子站通讯报警
			END_IF		
			//判断指令类型
			CASE eCmd OF
					//夹爪
					RGI_14_CMD.Cmd_Clamp,RGI_14_CMD.Cmd_Release://执行夹爪指令	
                        eClampActCmd := eCmd ;				
						CmdClampAction(xComplete=> xComplete);
					//绝对旋转	
					RGI_14_CMD.Cmd_RotateAbsClamp , RGI_14_CMD.Cmd_RotateAbsRelease ://执行旋转指令
						CmdRotateAction_ABS(xComplete=> xComplete);
					//相对旋转
					RGI_14_CMD.Cmd_RoratRelClamp , RGI_14_CMD.Cmd_RoratRelRelease://执行旋转指令
						CmdRotateAction_Ref(xComplete=> xComplete);
					//初始化
					RGI_14_CMD.Cmd_Org://执行回原点指令
						mCmdOrgAction(xComplete=> xComplete);
						
						
					ELSE
						;	
				END_CASE  
      UNTIL (TRUE)
	END_REPEAT
END_IF


IF xAbort OR xComplete OR eErrorID<>RGI_14_ERROR.NO_ERROR THEN    
    (*
    * Cleaning
    * => free as much allocated resources as possible
    *)    
    tOperationTimer(IN:=0);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleAbortedState" Id="{512f0c46-95a1-4959-ae19-c7bdb01e9f9f}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleAbortedState
VAR_INPUT
END_VAR
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
VAR
	xComplete: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF xAborted AND xResetRequest THEN
    eState:=STATE.RESETING;
    xAgain:=1;
ELSE
    xBusy:=0;
    xAborted:=1;
    //xResetRequest:=(xExecute=0);
    xAgain:=0;(* !!! *)
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleAbortingState" Id="{a65d2ae1-dbaa-4620-ad9a-31655db3ce2a}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleAbortingState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
VAR
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AbortAction(xComplete=> xComplete, eErrorID=> eErrorID);

IF eErrorID<>RGI_14_ERROR.NO_ERROR THEN
    eState:=STATE.INERROR;
    xAgain:=1;
ELSIF xComplete THEN
    eState:=STATE.ABORTED;
    xAgain:=1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleDoneState" Id="{2b555aaf-30c6-4733-b698-8850c01e41dd}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleDoneState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//在运行过程中要是切换模式，再运行完成之后，检测到模式的切换，就需要回到初始位置，进行下一次执行准备
IF _xDone AND ((xExecute=0) OR ( _xModeChange AND NOT _xAutoOpe ) OR ( NOT xAutoMode AND NOT xDeviceRunning AND ( NOT _xAutoOpe OR _xHMIOpe))) THEN
	eState:=STATE.RESETING;
	xAgain:=1;
ELSE
	xBusy:=0;
	_xDone:=1;
	//xResetRequest:=(xExecute=0);
	xAgain:=0;(* !!! *)
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleDormantState" Id="{65b758a0-2a48-4e24-b938-36c663e2a274}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleDormantState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF xExecute THEN
    xBusy:=1;
    eState:=STATE.EXECUTING;
    xAgain:=1;
END_IF

//下面两个报警一旦报警就需要发生
IF _xConnectError 
THEN//出现这个进行报警
	eERRORID := RGI_14_ERROR.FLT_CONNECT;//子站通讯报警
END_IF
IF st_IOData.I_DeviceERRORState <> 0//检测硬件是否报错
THEN
	eERRORID := RGI_14_ERROR.FLT_DEVICE_ERROR;//需要检查硬件，硬件有问题
END_IF

IF _fResetCheck.Q//清空报警
THEN
	eERRORID := RGI_14_ERROR.No_ERROR;
END_IF
(********************************等待手动操作******************************)
//初始化指令
_rHMIInit(CLK:= stOper.xHMInitButton AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting );
_rInit(CLK:= stOper.xInitControl AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR  xDeviceRunning OR xIniting));
IF _rHMIInit.Q OR _rInit.Q
THEN
	eCmd := RGI_14_CMD.Cmd_Org;
	xExecute := TRUE;
END_IF

FOR ii := 1 TO 10 BY 1
DO 
	//夹紧轴夹紧控制
	_rHMIClamp[ii](CLK:= stOper.aHMIClampButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rClamp[ii](CLK:= stOper.aClampControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR xDeviceRunning OR xIniting ) );
	IF _rHMIClamp[ii].Q OR _rClamp[ii].Q
	THEN
		iTorqueSet :=stPosPara.aHMIClampiTorqueSet[ii];
		iSpeedSet := stPosPara.aHMIClampiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIClampiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_Clamp;
		xExecute := TRUE;
	END_IF	
	//夹紧轴松开指令
	_rHMIRelease[ii](CLK:= stOper.aHMIReleaseButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rRelease[ii](CLK:= stOper.aReleaseControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR  xDeviceRunning OR xIniting));
	IF _rHMIRelease[ii].Q OR _rRelease[ii].Q
	THEN
		iTorqueSet := stPosPara.aHMIReleasepiTorqueSet[ii];
		iSpeedSet :=stPosPara.aHMIReleasepiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIReleasepiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_Release;
		xExecute := TRUE;
	END_IF		
	//旋转轴关盖控制
	_rHMIRotateClamp[ii](CLK:= stOper.aHMIRotateClampButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rRotateClamp[ii](CLK:= stOper.aRotateClampControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR xDeviceRunning OR xIniting) );
	IF _rHMIRotateClamp[ii].Q OR _rRotateClamp[ii].Q
	THEN
		iTorqueSet := stPosPara.aHMIRotateiTorqueSet[ii];
		iSpeedSet := stPosPara.aHMIRotateClampiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIRotateClampiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_RotateAbsClamp;
		xExecute := TRUE;
	END_IF	
	//旋转轴松盖指令
	_rHMIRotateRelease[ii](CLK:= stOper.aHMIRotateReleaseButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rRotateRelease[ii](CLK:= stOper.aRotateReleaseControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR  xDeviceRunning OR xIniting ));
	IF _rHMIRotateRelease[ii].Q OR _rRotateRelease[ii].Q
	THEN
		iTorqueSet := stPosPara.aHMIRotateReleaseiTorqueSet[ii];
		iSpeedSet := stPosPara.aHMIRotateReleaseiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIRotateReleaseiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_RotateAbsRelease;
		xExecute := TRUE;
	END_IF	
	
	//相对旋转夹紧控制
	_rHMIRotateClampRef[ii](CLK:= stOper.aHMIRotateClampRefButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rRotateClampRef[ii](CLK:= stOper.aRotateClampRefControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR xDeviceRunning OR xIniting) );
	IF _rHMIRotateClampRef[ii].Q OR _rRotateClampRef[ii].Q
	THEN
		iTorqueSet := stPosPara.aHMIRotateRefiTorqueSet[ii];
		iSpeedSet := stPosPara.aHMIRotateClampRefiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIRotateClampRefiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_RoratRelClamp;
		xExecute := TRUE;
	END_IF
	//相对旋转松开控制
	_rHMIRotateReleaseRef[ii](CLK:= stOper.aHMIRotateReleaseRefButton[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND NOT xAutoMode AND NOT xDeviceRunning AND NOT xIniting);
	_rRotateReleaseRef[ii](CLK:= stOper.aRotateReleaseRefControl[ii] AND eErrorID = RGI_14_ERROR.NO_ERROR AND ( xAutoMode OR xDeviceRunning OR xIniting ) );
	IF _rHMIRotateReleaseRef[ii].Q OR _rRotateReleaseRef[ii].Q
	THEN
		iTorqueSet := stPosPara.aHMIRotateReleaseRefiTorqueSet[ii];
		iSpeedSet := stPosPara.aHMIRotateReleaseRefiSpeedSet[ii];
		iPosAngleSet := stPosPara.aHMIRotateReleaseRefiPosAngleSet[ii];
		eCmd := RGI_14_CMD.Cmd_RoratRelRelease;
		xExecute := TRUE;
	END_IF
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleErrorState" Id="{fcc2f5c1-4f22-4e8a-a5a8-ce39335422d0}">
      <Declaration><![CDATA[METHOD PRIVATE FINAL HandleErrorState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF xError THEN
	IF eErrorID < RGI_14_ERROR.FLT_ClAMP_CLAMPFAIL//正常执行报警
	THEN
		IF xResetRequest OR NOT xExecute//按照正常逻辑进行处理复位处理就可以
		THEN
				eState:=STATE.RESETING;
				xAgain:=1;
		END_IF
	ELSE//操作失败报警（有可能需要进行程序跳步处理，此时，在自动模式下不允许被复位掉，防止，程序异常死机）
		IF ( NOT xAutoMode AND xIniting ) OR xAutoMode
		THEN 
			IF NOT xExecute//按照正常逻辑进行处理复位处理就可以
			THEN 
				eState:=STATE.RESETING;
				xAgain:=1;
			END_IF
		ELSE
			IF xResetRequest OR NOT xExecute//按照正常逻辑进行处理复位处理就可以
			THEN
				eState:=STATE.RESETING;
				xAgain:=1;
			END_IF
		END_IF
	END_IF
ELSE
	xBusy:=0;
	xError:=1;    
	xAgain:=0;(* !!! *)
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleExecutingState" Id="{f49f83ea-0282-41d3-ace3-a715ad952ec5}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleExecutingState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
VAR
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF xAbort=0 THEN   
    CyclicAction(xComplete=> xComplete);
END_IF

IF eErrorID<>RGI_14_ERROR.NO_ERROR THEN
    eState:=STATE.INERROR;
    xAgain:=1;
ELSIF xAbort THEN
    eState:=STATE.ABORTING;
    xAgain:=1;
ELSIF xComplete THEN
    eState:=STATE.DONE;
    xAgain:=1;
END_IF ]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleResettingState" Id="{906ecc5d-2d93-4e1f-97cc-a1185822beca}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PRIVATE FINAL HandleResettingState
VAR_OUTPUT
	xAgain: BOOL;
END_VAR
VAR
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResetAction(xComplete=> xComplete);

IF xComplete THEN
	xExecute:=0;//清除输入指令 
    xBusy:=0;
    _xDone:=0;
    xError:=0;
    xAborted:=0;
    eErrorID:=RGI_14_ERROR.NO_ERROR;
    eState:=STATE.DORMANT;
    xFirstInvocation:=1;
    xAgain:=0;(* !!! *)
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCmdOrgAction" Id="{82dbd3e1-5057-4bfe-bd9e-89d06859905b}" FolderPath="Control\">
      <Declaration><![CDATA[METHOD PROTECTED mCmdOrgAction
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
VAR
	thebn: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// return the real actual fault number
IF eErrorID <> RGI_14_ERROR.NO_ERROR
THEN
  RETURN;  
END_IF

CASE _diCmdState OF
	0://a相关数据初始化
		xRefOk := FALSE;//因为需要重新初始化，所以需要清除回原点完成标志位	
		_tonDelay(IN:= FALSE);
		st_IOData.O_RotateAngleLSet := 0;
		st_IOData.O_RotateAngleHSet := 0;
		st_IOData.O_RotateRelAngle := 0;
		IF NOT _aRead_VAR[5].bExecute THEN//没有读取任务
			_diCmdState := _diCmdState + 1;
		END_IF			
		
	1://初始化赋值
		_tonDelay(IN:= TRUE,pt:=T#20MS);
		st_IOData.O_Init := 16#A5;//触发回原点指令
		IF _tonDelay.Q//错开刷新时序
		THEN  
			_tonCmdTimeout(in:=FALSE); 
			_tonDelay(IN:=FALSE);
			_aEnableSignal[0]:=TRUE;   
			_diCmdState := _diCmdState+1;
		END_IF
		
	2://等待使能失效被响应	
		_tonCmdTimeout(IN:= _aEnableSignal[0],pt:=T#2S);
		_tonDelay(IN:=NOT _aEnableSignal[0],PT:=T#200MS);
		IF _tonDelay.Q
		THEN
			_tonCmdTimeout(in:=FALSE);
			SysMemSet(ADR(_aFeedbackData),0,SIZEOF(_aFeedbackData));
			_diCmdState := _diCmdState +1; 
		END_IF	
		
		IF _iSendReceiveState = 999//指令超时报错
		THEN
			eErrorID := RGI_14_ERROR.FLT_ORGCMD_TIMEOUT;		
			_diCmdState := 999;
		END_IF  
		
	3://设置读取数据反馈	 
		_tonCmdTimeout(in:=FALSE);
		_tonTimeout(in:=TRUE,pt:=T#10S); 
		_tonDelay(IN:= FALSE);
		_aEnableSignal[5] := TRUE;//读取状态信息
		_diCmdState := _diCmdState +1; 
		
	4://等待数据接收完成		
		_tonTimeout(in:=TRUE,pt:=T#10S); 
		_tonCmdTimeout(IN:= TRUE,pt:=T#2S); 
		IF NOT _aEnableSignal[5]//等待电动夹爪响应 
		THEN			
			_tonDelay(IN:= TRUE,pt:=T#40MS);//设置刷新周期
			IF st_IOData.I_ClampInit = 1 AND st_IOData.I_RotateInit = 1  //判断是否初始化成功
			THEN
				_tonCmdTimeout(in:=FALSE);
				_tonDelay(IN:= FALSE);
				_tonTimeout(in:=FALSE);  
				_diCmdState := 100;
				xRefOk := TRUE;//标记回原点成功
				xComplete := 1;
			END_IF
			IF _tonDelay.Q
			THEN
				_diCmdState := 3;
			END_IF
		END_IF	
		IF _iSendReceiveState = 999//回原点指令响应超时
		THEN
			eErrorID := RGI_14_ERROR.FLT_ORGCMD_TIMEOUT;		
			_diCmdState := 999;
		END_IF	
		IF _tonTimeout.Q//回原点动作超时
		THEN
			eErrorID := RGI_14_ERROR.FLT_ORG_TIMEOUT;
			_diCmdState := 999;
		END_IF			
	ELSE
		;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetAction" Id="{5130cd55-cc7c-4cee-97f7-f66e1db150b5}">
      <Declaration><![CDATA[///{attribute 'tc_no_symbol'}
METHOD PROTECTED ResetAction
VAR_OUTPUT
	xComplete: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
* Cleaning
* => free all allocated resources
* => reinitialize instance variables
*)
tOperationTimer(IN:=0);

// init command state
_diCmdState := 0;
_iAbortState := 0;
_tonCmdTimeout(in:=FALSE);
_tonTimeout(in:=FALSE);
_tonDelay(IN:=FALSE);
_xRotateFinish := FALSE;
_xModeChange := FALSE;
_xReadStatus :=  TRUE;
_iNGCount := 0;

//清除触发标志位
FOR i:= 0 TO 5 BY 1
DO
	_aEnableSignal[i] := FALSE;
END_FOR
FOR i:= 4 TO 5 BY 1
DO
	_aRead_VAR[i].bExecute:= FALSE; 
END_FOR
FOR i:= 0 TO 3 BY 1
DO
	_aWtirt_VAR[i].bExecute:= FALSE; 
END_FOR

FOR ii :=1 TO 10 DO
	//手头指令清除
	stOper.aHMIClampButton[ii]:=FALSE;
	stOper.aHMIReleaseButton[ii]:=FALSE;
	stOper.aHMIRotateClampButton[ii]:=FALSE;
	stOper.aHMIRotateClampRefButton[ii]:=FALSE;
	stOper.aHMIRotateReleaseButton[ii]:=FALSE;
	stOper.aHMIRotateReleaseRefButton[ii]:=FALSE;
	stOper.xHMInitButton:=FALSE;	
	//自动指令操作
	stOper.aClampControl[ii]:=FALSE;
	stOper.aReleaseControl[ii]:=FALSE;
	stOper.aRotateClampControl[ii]:=FALSE;
	stOper.aRotateClampRefControl[ii]:=FALSE;
	stOper.aRotateReleaseControl[ii]:=FALSE;
	stOper.aRotateReleaseRefControl[ii]:=FALSE;
	stOper.xInitControl:=FALSE;	
END_FOR



//清除触发标志位
xComplete:=1;	

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_RGI_14_Modbus_1">
      <LineId Id="3" Count="84" />
      <LineId Id="2" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="322" Count="13" />
      <LineId Id="307" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.AbortAction">
      <LineId Id="3" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.ACTCheckRotateFinish">
      <LineId Id="2" Count="20" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.ACTMap">
      <LineId Id="2" Count="57" />
      <LineId Id="103" Count="3" />
      <LineId Id="60" Count="42" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.CmdClampAction">
      <LineId Id="3" Count="148" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.CmdRotateAction_ABS">
      <LineId Id="3" Count="14" />
      <LineId Id="147" Count="0" />
      <LineId Id="19" Count="123" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.CmdRotateAction_Ref">
      <LineId Id="3" Count="141" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.ConnectAction">
      <LineId Id="9" Count="2" />
      <LineId Id="193" Count="7" />
      <LineId Id="213" Count="0" />
      <LineId Id="206" Count="6" />
      <LineId Id="27" Count="0" />
      <LineId Id="214" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="217" Count="11" />
      <LineId Id="215" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="231" Count="11" />
      <LineId Id="230" Count="0" />
      <LineId Id="216" Count="0" />
      <LineId Id="243" Count="11" />
      <LineId Id="44" Count="0" />
      <LineId Id="255" Count="12" />
      <LineId Id="52" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="87" Count="17" />
      <LineId Id="287" Count="0" />
      <LineId Id="106" Count="27" />
      <LineId Id="135" Count="22" />
      <LineId Id="159" Count="19" />
      <LineId Id="272" Count="0" />
      <LineId Id="278" Count="2" />
      <LineId Id="274" Count="2" />
      <LineId Id="269" Count="0" />
      <LineId Id="180" Count="4" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.CyclicAction">
      <LineId Id="3" Count="11" />
      <LineId Id="79" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="75" Count="3" />
      <LineId Id="15" Count="48" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleAbortedState">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleAbortingState">
      <LineId Id="3" Count="9" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleDoneState">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleDormantState">
      <LineId Id="3" Count="100" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleErrorState">
      <LineId Id="3" Count="29" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleExecutingState">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.HandleResettingState">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.mCmdOrgAction">
      <LineId Id="3" Count="33" />
      <LineId Id="92" Count="0" />
      <LineId Id="37" Count="47" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RGI_14_Modbus_1.ResetAction">
      <LineId Id="3" Count="14" />
      <LineId Id="64" Count="0" />
      <LineId Id="18" Count="34" />
      <LineId Id="54" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>